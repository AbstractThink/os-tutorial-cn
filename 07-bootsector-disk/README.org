[[file:./README_en.md][English]]

/事先需要 Google 的概念： hard disk(硬盘), cylinder(柱面), head(磁头), sector(扇区), carry bit(CF 标志)/

*目标：让启动程序加载磁盘数据用于启动内核*

我们的 OS 不可能控制在 512 字节以内，因此，我们需要从磁盘中加载数据并运行这个内核。

幸运地是，我们不需要处盘面转动的开关，我们只需要调用一些 BIOS 例程即可，就像我们之前在屏幕上打印字符一样。
要实现它，我们需要设置 =al = 0x02= (其它寄存器设置必要的柱面、磁头、扇区), 之后抛出 =0x13= 中断即可。

你可以参考 =13h= 号中断的 [[http://stanislavs.org/helppc/int_13-2.html][指导]]

在这节课，我们第一次使用 =carry bit= ，这是存在于每个寄存器之外的位，用于保存一个操作是否会超出当前的寄存器的承载能力：

#+BEGIN_SRC asm
mov ax, 0xFFFF
add ax, 1 ; ax = 0x0000 and carry = 1
#+END_SRC

这个 =carry bit= 不会被直接使用，而是在其它操作的控制结构被使用，如 =jc(如果 carry 位被置位)= .

BIOS 也会在 =al= 中保存需要读取的扇区数，因此，需要一直判断是否到达期望值。

** 代码
打开测试文件 =boot_sect_disk.asm= 完成从读磁盘例程。

=boot_sect_disk.asm= 准备了读盘参数并调用 =dist_load= 函数。注意我们是如何写入一些实际上不属于启动扇区的数据，因为它们在 512 位标记之后了。

启动扇区实际上是第0块硬盘的第0个磁头的0个柱面的第1个扇区（第一，扇区从 1 开始）

因此，任何在 512 字节之外的数据都属于第0块硬盘第0个磁头第0个柱面的第2个扇区。

主例程将填充一些样本数据， 接着让启动扇区程序读这些数据。

注意：如果你碰到错误了，但你的代码没问题，确保 qemu 从正确的驱动号启动，并在 =dl= 上设置驱动号。

BIOS 在调用启动加载器之前设置 =dl= 为驱动号。然而，我发现 qemu 从硬盘启动会出现一些问题。

这里是两个快捷选项:

- 尝试使用 =-fda= 标志，比如： =qemu -fda boot_sect_main.bin=, 这个将会设置 =dl = 0x00=, 这似乎可以工作
- 显式使用 =-boot= 标记， 例如： =qemu boot_sect_main.bin -boot c= , 这样会将 =dl= 自动设置为 =0x80= ,并且让启动加载程序读数据
