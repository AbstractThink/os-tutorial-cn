[[file:./README_en.md][English]]

/事先需要 Google 的概念： segmentation(段)/

*目标: 学习在 16 位实模式下，内存段是如何寻址的*

如果你对段很熟悉，可以跳过本次课程。

我们在第 3 节课中使用 =[org]= 操作过段。使用分段意味着你只需要一个偏移就可以引用所有的数据。

分段使用特殊的寄存器完成： =cs=, =ds=, =ss=, =es=, 分别对应于代码，数据，栈，额外（用户定义的）。

注意：它们通过 CPU 隐式使用，因此，一旦你设定了具体值，比如 ds, 那么之后的所有内存寻址将是相对于 =ds= 的偏移值。[[http://wiki.osdev.org/Segmentation][阅读更多]]

而且，在计算实际地址的时候，我们不只将两个地址联结起来，而是把它们重叠起来： segment << 4 + address. 例如， =ds= 是 =0x4d= , 那么 =[0x20]= 实际上引用的是： =0x4d << 4 + 0x20 = 0x4f0=

为了充分理解理论，看一代码并尝试玩一下。

提示：我们不能直接使用 =mov= 语义来操作这些寄存器，必须使用通用寄存器间接使用。
