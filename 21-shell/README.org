[[file:./README_en.md][English]]

*目标：清理一些代码，然而解析用户输入*

在这节课，我们只做两件事。首先我们要整理一下代码，为接下来的课程做准备。在之前的
课程里，我尝试将一些东西放在大部分预计的地方。但是，当代码基数持续增加时，将它们
与当前或未来需求进行适配是一个好的实践。

** 代码清理
首先，我们快速地从我们需要处理字符串的有用函数等出发。在一个正常的 OS 中，这个
叫做 C 库函数 或者短一点，叫 =libc= 。

目前，我们有一个 =util.c=
文件，这个文件可以拆分为 =mem.c= 和
 =strin.h= 文件，以及它们的头文件，

 第二，我们将创建一个新方法 =irq_install()= , 以便内核只需要执行一个函数就
 可以初始化所有的 IRQs . 这个方法和 =isr_install()= 类似，同样被放在了
 对应的 =irq.c= 文件中。

 在这里，我们将禁用 =timer_callback()= 中的
 =kprint()= 方法，避免在屏幕上填满垃圾，现在我们已经知道了它的工作的很好。

 =cpu= 和 =drivers= 之间没有一个明确的区分，记住我是从多份资料中创建这份教程的，
 它们都有区分度的文件夹格式。我们只需要做的就是将 =drivers/ports.*= 移动到
 =CPU/= 中去，因为它们明显是依赖于 cpu 的代码。

 =boot= 也是依赖于 cpu 的代码，但是我们不会乱动它，直到我们需要为一个不同的机器
 实现一个启动序列。

 还有就是 =Makefile= 文件中许多
 =CFLAGS= 发生了改变，因为从现在开始，我们要为 C 库创建一些更级的函数。如果
 我们有一个错误的声明，我们并不想编译器包含一些额外的代码。

 我们也增加了一些标志，将警告转换为错误，因为一个很明显的小错误就是指针之后才会
 抛出。这也强制我们修改代码中的一些指针声明。

 最后，我们增加一个宏避免在 =libc/function.h= 中的未使用参数警告-错误信息。

 ** 键盘字符
 接下来，如何使用按下的字符？

 - 当一个键被按下的时候，回调根据在 =kerboard.c= 中定义的新数组获得 ASCII 码。
 - 回调将字符添加到缓冲区中
 - 同时将打印在屏幕上
 - 当 OS 想读取用户输入时，它调用 =libc/io.c:readline()=

 =kerboard.c= 也能解析退格键，通过移除按键缓冲区的最后一个元素，并调用
 =screen.c:kprint_backspace()= 将其从屏幕上删除。为了实现这个，我们需要修改
 =print_char()= 打印退格键是偏移不要前进。

 ** 用户输入的响应
 键盘回调会检查一个新行，然后告诉内核用户输入了一些东西。 检查 libc 函数 =strcmp()=
 的对比结果， 这个函数用于比较两个字符串，如果它们相等就返回 0， 如果用户输入 "END", 我们将 CPU 停机，

这是最基本的 shell，但是你应该自豪，因为我们是从零开始的。意识到它很酷了么？

如果你想愿意，可以扩展 =kernel.c= 以解析更多的东西。在之后，我将有一个文件系统，
我们将允许用户运行一些基本的命令。 
